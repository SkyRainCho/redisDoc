# Redis主从复制

虽然*Redis*单机可以承载十万量级的并发请求，但是依然具有处理能力的上限，考虑正常情况下，对于数据的读取请求要远大对数据的写入请求。基于这个前提，*Redis*设计了一个复制的机制，应用这个复制机制，其他的*Redis*服务器可以拥有一个不断更新的数据副本，这样其他拥有数据副本的*Redis*服务器可以分担用户的读取请求，这样一来可以进一步提升*Redis*的并发能力，本篇文章将对*Redis*主从复制机制的相关功能与实现细节进项介绍。


## 复制功能概述
简单来说*Redis*的复制功能主要可以划分两个阶段：
1. **数据同步**：*Slave*节点通过某种方式获取*Master*节点的数据副本，并将其加载到内存键空间之中，使该*Slave*节点成为*Master*节点的镜像节点。
1. **命令转发**：*Master*节点在执行命令时，将该命令转发给自己的*Slave*节点，以便在运行之中保证*Master*实例与*Slave*实例之间数据的一致性。

### 数据同步
*Redis*可以通过两种方式开启**数据同步**：
1. 通过配置文件，在*redis.conf*配置文件之中，配置`replicaof <masterip> <masterport>`这条配置项，可以设置对应*Master*节点的地址；如果*Master*实例需要密码认证，可以通过`masterauth <master-password>`配置项来设置连接*Master*所需要认证密码。
1. 执行**REPLICAOF**命令，命令的格式为`REPLICAOF host port`，通过这条命令，可以使执行这条命令的*Redis*成为给定地址`host`以及`port`的另一个*Redis*实例的*Slave*节点，不过这条命令有一个缺陷，如果你对应的*Master*节点需要密码验证，而在*redis.conf*配置文件之中没有提前设定*Master*节点的认证密码，那么需要在执行**REPLICAOF**命令之前，先通过**CONFIGSET**命令来设置`masterauth`的认证密码，否则将无法建立主从实例之间的数据同步。

数据同步相当于将*Master*上键空间之中的全部数据发送给*Slave*实例，如果看过前面对于**RDB**持久化的介绍，我们可以发现这其中有很多相似之处，而实际上*Master*实例与*Slave*实例之间的数据同步也是通过**RDB**的机制来实现的。在*Redis*之中，复制机制中待同步数据的准备与传输方式有两种：

1. *Redis*使用正常的方式，启动一个后台子进程来生成**RDB**文件到磁盘上，等待磁盘上的*RDB*文件生成结束，在通过网络连接将这个**RDB**文件发送给*Slave*节点。
2. 如果*Master*实例所在的服务器上的磁盘性能很低的话，那么先向磁盘中写入数据再从磁盘进行读取与网络传输的话，会导致数据同步的效率很低。对于这种情况，*Redis*设计了一种无盘的数据同步方式，也就是不通过磁盘文件，而是在生成**RDB**文件的过程之中，直接将数据写入与*Slave*实例所建立的连接的套接字文件描述符上，*Slave*实例直接通过网络来接收*Master*发来的同步数据，这样可以大大提升针对单一*Slave*实例同步的速度。而这得益于**Linux**操作系统中*一切皆文件*的设计理念以及*Redis*自身实现的`rio`通用IO对象数据结构。

虽然采用无盘方式进行数据同步的策略，会提升单一*Slave*实例的同步效率，免去了磁盘IO所带来的延时，但是这种方式也有一个问题，便是在多个*Slave*需要数据同步的时候，无法复用**RDB**文件，哪怕两个*Slave*实例的同步请求相聚很短事件内到达*Master*实例，*Master*也不得不进行重复两次**RDB**的生成过程。那么采用有磁盘的方式来进行数据同步的话，如果在生成**RDB**文件的过程中，又有一个*Slave*实例期望与*Master*实例之间进行数据同步的话，那么我们可以在**RDB**文件生成结束之后，将这个文件发送给多个等待数据同步的*Slave*实例，免去了重复生成**RDB**文件所带来的系统负载。

上面所介绍的**数据同步**方式，无论是有盘的还是无盘的，其本质都是对*Master*实例上的数据进行一次全量的备份，*Slave*实例使用这个全量的数据备份还原*Master*上的数据。通过后面我们将要介绍的**命令转发**，*Master*与*Slave*之间可以保持数据上的一致性。但是如果在日常的运行之中，*Master*与*Slave*之间的网络连接出现问题，被转发的命令无法传递到*Slave*实例上，这将导致二者数据的不一致，为了解决这个问题，当*Slave*与*Master*直接重新建立连接时，会重新执行一次**数据同步**以继续维持两者间数据的一致性。早期的*Redis*也确实使用这种方式在重连时进行全量的**数据同步**的，但是这其中也存在一个问题，

*如果两者之间断线的时间很短呢？是否有必要为了极小的数据差异进行一次全量的数据同步呢？*。

在新版本的*Redis*之中，作者针对这个问题做出了一个优化，也就是引入了**增量数据同步**的机制，应用这个机制，*Redis*可以在*Master*实例与*Slave*实例数据差异较小的情况下，仅对增量的数据差异进行同步，而无须再进行全量的**数据同步**，可以大大提升同步的效率。

### 命令转发

## 复制功能相关数据结构

## 从Master角度看复制功能

## 从Slave角度看复制功能


***
![公众号二维码](https://machiavelli-1301806039.cos.ap-beijing.myqcloud.com/qrcode_for_gh_836beef2355a_344.jpg)

喜欢的同学可以扫描二维码，关注我的微信公众号，*马基雅维利incoding*