# Redis主从复制

虽然*Redis*单机可以承载十万量级的并发请求，但是依然具有处理能力的上限，考虑正常情况下，对于数据的读取请求要远大对数据的写入请求。基于这个前提，*Redis*设计了一个复制的机制，应用这个复制机制，其他的*Redis*服务器可以拥有一个不断更新的数据副本，这样其他拥有数据副本的*Redis*服务器可以分担用户的读取请求，这样一来可以进一步提升*Redis*的并发能力，本篇文章将对*Redis*主从复制机制的相关功能与实现细节进项介绍。


## 复制功能概述
首先，彼此连接的*Master*实例与*Slave*实例是互为客户端的关系，在前面我们介绍客户端相关内容时，我们介绍了`client.flags`这个字段以掩码的形式记录了当前客户端的状态。而*Master*实例与*Slave*实例从各自的角度看对方，都是一个`client`对象，而在*src/server.h*之中也为*Master*与*Slave*实例定义了对应的状态掩码：
```c
#define CLIENT_SLAVE (1 << 0)
#define CLIENT_MASTER (1 << 1)
```

*Redis*本身也支持一个*Matser*实例连接多个*Slave*实例的模式，这样可以进一步提升系统的并发能力。*Redis*甚至可以在配置文件*redis.conf*之中通过配置项`min-reolicas-to-write`来指定*Master*实例所需要的*Slave*实例的最小数量，一旦*Matser*实例对应的*Slave*数量不足，则可以认为这个*Master*处于一种异常的状态，*Master*实例可以拒绝在这个状态下执行写命令。

然而如果一个*Master*实例连接了过多的*Slave*实例的话，*Master*与*Slave*之间的数据传输对于*Master*实例本身来说也会造成一定的网络负载，因此*Redis*还支持一种层次化的主从模式，也就是说一个*Slave*实例也可以拥有它自己的*Slave*，我们可以称之为*Sub-Slave*。基于这种层次化的结构，顶层的*Master*实例只需要与若干个*Slave*实例进行数据传输，在有这些与顶层*Master*直连的*Slave*将数据发送给更为下层的*Slave*实例，以降低数据传输对*Master*实例性能所带来的影响。

简单来说*Redis*的复制功能主要可以划分两个阶段：
1. **数据同步**：*Slave*节点通过某种方式获取*Master*节点的数据副本，并将其加载到内存键空间之中，使该*Slave*节点成为*Master*节点的镜像节点。
1. **命令转发**：*Master*节点在执行命令时，将该命令转发给自己的*Slave*节点，以便在运行之中保证*Master*实例与*Slave*实例之间数据的一致性。

### 数据同步
*Redis*可以通过两种方式开启**数据同步**：
1. 通过配置文件，在*redis.conf*配置文件之中，配置`replicaof <masterip> <masterport>`这条配置项，可以设置对应*Master*节点的地址；如果*Master*实例需要密码认证，可以通过`masterauth <master-password>`配置项来设置连接*Master*所需要认证密码。
1. 执行**REPLICAOF**命令，命令的格式为`REPLICAOF host port`，通过这条命令，可以使执行这条命令的*Redis*成为给定地址`host`以及`port`的另一个*Redis*实例的*Slave*节点，不过这条命令有一个缺陷，如果你对应的*Master*节点需要密码验证，而在*redis.conf*配置文件之中没有提前设定*Master*节点的认证密码，那么需要在执行**REPLICAOF**命令之前，先通过**CONFIGSET**命令来设置`masterauth`的认证密码，否则将无法建立主从实例之间的数据同步。

无论上面哪种建立主从复制的方式，**数据同步**都不是立即开始的，这两种方式仅是为将要充当*Slave*的服务器设置了*Master*的地址，真正开启数据同步则是在设置了*Master*地址信息之后，*Slave*通过一系列内部命令来实现的：
1. 通过设置的*Master*地址信息，建立*Slave*与*Master*之间的Socket连接。
1. *Slave*向*Master*发送**PING**命令以检验二者连接是否正常。
1. 如果*Master*需要密码认证，则发送**AUTH**命令验证密码。
1. *Slave*会向*Master*发送一系列的**REPLCONF**命令，将*Slave*的信息通知给*Master*。
1. *Slave*向*Master*发送**PSYNC**命令，以正式的开启**数据同步**。

数据同步相当于将*Master*上键空间之中的全部数据发送给*Slave*实例，如果看过前面对于**RDB**持久化的介绍，我们可以发现这其中有很多相似之处，而实际上*Master*实例与*Slave*实例之间的数据同步也是通过**RDB**的机制来实现的。在*Redis*之中，复制机制中待同步数据的准备与传输方式有两种：

1. *Redis*使用正常的方式，启动一个后台子进程来生成**RDB**文件到磁盘上，等待磁盘上的*RDB*文件生成结束，在通过网络连接将这个**RDB**文件发送给*Slave*节点。
2. 如果*Master*实例所在的服务器上的磁盘性能很低的话，那么先向磁盘中写入数据再从磁盘进行读取与网络传输的话，会导致数据同步的效率很低。对于这种情况，*Redis*设计了一种无盘的数据同步方式，也就是不通过磁盘文件，而是在生成**RDB**文件的过程之中，直接将数据写入与*Slave*实例所建立的连接的套接字文件描述符上，*Slave*实例直接通过网络来接收*Master*发来的同步数据，这样可以大大提升针对单一*Slave*实例同步的速度。而这得益于**Linux**操作系统中*一切皆文件*的设计理念以及*Redis*自身实现的`rio`通用IO对象数据结构。

虽然采用无盘方式进行数据同步的策略，会提升单一*Slave*实例的同步效率，免去了磁盘IO所带来的延时，但是这种方式也有一个问题，便是在多个*Slave*需要数据同步的时候，无法复用**RDB**文件，哪怕两个*Slave*实例的同步请求相聚很短事件内到达*Master*实例，*Master*也不得不进行重复两次**RDB**的生成过程。那么采用有磁盘的方式来进行数据同步的话，如果在生成**RDB**文件的过程中，又有一个*Slave*实例期望与*Master*实例之间进行数据同步的话，那么我们可以在**RDB**文件生成结束之后，将这个文件发送给多个等待数据同步的*Slave*实例，免去了重复生成**RDB**文件所带来的系统负载。

上面所介绍的**数据同步**方式，无论是有盘的还是无盘的，其本质都是对*Master*实例上的数据进行一次全量的备份，*Slave*实例将网络连接上接收到的同步数据写入一个本地文件之中，当传输接收之后通过`rdbLoad`接口使用这个全量的数据备份还原*Master*上的数据。通过后面我们将要介绍的**命令转发**，*Master*与*Slave*之间可以保持数据上的一致性。但是如果在日常的运行之中，*Master*与*Slave*之间的网络连接出现问题，被转发的命令无法传递到*Slave*实例上，这将导致二者数据的不一致，为了解决这个问题，当*Slave*与*Master*直接重新建立连接时，会重新执行一次**数据同步**以继续维持两者间数据的一致性。早期的*Redis*也确实使用这种方式在重连时进行全量的**数据同步**的，但是这其中也存在一个问题，

*如果两者之间断线的时间很短呢？是否有必要为了极小的数据差异进行一次全量的数据同步呢？*。

在新版本的*Redis*之中，作者针对这个问题做出了一个优化，也就是引入了**增量数据同步**的机制，应用这个机制，*Redis*可以在*Master*实例与*Slave*实例数据差异较小的情况下，仅对增量的数据差异进行同步，而无须再进行全量的**数据同步**，可以大大提升同步的效率。

所谓**增量数据同步**，其设计思路是：
1. 在*Master*一侧，
    1. 维护一个唯一复制ID`replid`，用于区分各个*Redis*实例；
    1. 维护一个复制偏移`master_repl_offset`，用于记录当前*Master*实例累积转发命令的计数，每转发一条命令，便会将该命令的长度信息累加到`master_repl_offset`这个偏移量上；
    1. 维护一个有限长度的，先进先出的积压缓冲区`repl_backlog`，当一条命令被转发给*Slave*实例的时候，也会被写入积压缓冲区之中，同时如果积压缓冲区已满，会将最早被写入的数据清空，以便能够继续写入新的命令。
1. 而在*Slave*一层，代表*Master*的客户端之中也存储了*Master*实例同步过来的复制偏移量。

正常请求下，*Master*实例与*Slave*实例之中，各自的复制偏移量应该是相同的。一旦某个*Slave*实例掉线，那么将导致*Slave*上存储的复制偏移量落后于*Master*实例中的复制偏移量。如果这部分差异的数据恰好落在*Master*实例的积压缓冲区里的话，那么在重新连接建立之后，*Master*只需要将积压缓冲区里对应的数据发送给*Slave*实例就可以，而无需重新执行**RDB**的生成过程。只要在第一次建立连接或者重连时两者数据差异过大的时候，才会执行**RDB**的生成过程。

### 命令转发
参考前面介绍的**AOF**持久化策略，可以很好地理解命令转发这一概念。在*Master*实例与*Slave*实例完成数据同步之后，*Master*会在运行过程中将执行的命令发送给*Slave*对应的`client`客户端对象，同时也会将这个命令写入积压缓冲区，以便后续执行**增量数据同步**的流程。而在*Slave*端，*Master*发送来的命令则会被*Master*对应的`client`对象接收，并完成命令的解析与命令的执行，将*Master*端执行的命令在*Slave*一层重新执行一次，已完成数据的同步。而对应层次化结构的主从模式，*Slave*实例在接收到*Master*发送的命令之后，还会将这个命令转发给自己的*Slave*实例，也就是*Sub-Slave*实例，帮助*Sub-Slave*完成数据的同步。

## 复制功能相关数据结构

## 从Master角度看复制功能

## 从Slave角度看复制功能


***
![公众号二维码](https://machiavelli-1301806039.cos.ap-beijing.myqcloud.com/qrcode_for_gh_836beef2355a_344.jpg)

喜欢的同学可以扫描二维码，关注我的微信公众号，*马基雅维利incoding*