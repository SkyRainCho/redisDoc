# Redis中的基数统计HyperLogLog

## 何为基数统计
所谓基数统计，就是指从一组数据集中获取不重复出现的数据的个数，例如一组数据`[1, 2, 1, 0, 3, 5, 2]`，那么对于这组数据的基数统计结果便是5。基数统计在当下有很多应用的场景，例如统计一个网络游戏每天的登录账号的数量，一个账号一天之内可能会进行多次登录；又或者统计某个网站每天的访问IP地址来源，同样也会有同一个IP多次访问的情况。

对于C++程序员来说，遇到上述问题第一个会想到的便是使用**STL**标准库中的`std::set`或者`std::unordered_set`这两种容器进行数据统计，遍历原始数据集，将其中的每一条数据都插入容器之中，完成遍历之后容器的大小即为基数统计结果。

然而C++标准库中这种通用的方式存在一个隐患，对于数据集较小的情况下这种基于红黑树或者哈希表的方式较为适用同时得到的结果也一定是准确的。然而如果对于数据集很大的情况呢，比如10T大小的数据量同时重复数据比例很低的情况呢？如果依然采用类似**STL**标准库中的这种通用解决方案，那么使用`std::set`以及`std::unordered_set`存储数据，那么这些容器也会相应的占用大约10T左右的内存，这还仅仅是对一项数据进行基数统计，就要消耗如此多的内存。如果针对多个数据项进行基数统计，那么在数据集大小非常大的情况下，这种通用的方案显然是不能接受的。

考虑另外一个问题，对于拥有1亿条数据的数据集，假设其中不重复的数据有20000000条。如果我们给出一种方法，通过这种方法最后得出的基数统计的结果为19999914条，虽然不是准确的结果，但是是一个误差很小的结果，那么这种方法是否可以接收呢？进一步来说，如果这种虽然结果不准确但是误差很小的解决方案，同时还具有很快的运行效率，例如线性时间复杂度；并且消耗较少的内存，例如常量级的空间复杂度，那么这种方案是否可以接收呢？

**HyperLogLog**算法便是这样一种基于概率的基数统计算法，这个算法可以接收大小最大为`2^63`的数据集合，同时仅需要占用12K的内存，并且可以将基数统计结果的误差控制在0.86%以内。

*Redis*服务器也实现了**HyperLogLog**算法用于对数据进行基数统计，本文将介绍如何使用*Redis*中的**HyperLogLog**基数统计功能，以及介绍这个算法是如何实现的。不过本文将不会介绍这个算法在数学上的证明过程，如果有兴趣的同学可以自行搜索**HyperLogLog**算法的数学证明。

## Redis中基数统计功能的概述

*Redis*通过**PFADD**、**PFCOUNT**、**PFMERGE**这三个命令来实现基于**HyperLogLog**算法的。

### PFADD命令

    PFADD key element [element ...]

在*Redis*之中，每一个基数统计可以被认为是一个**HyperLogLog**对象，都会被存储在数据库的键空间之中，可以被持久化，拥有自己的键；通过**PFADD**命令，我们可以将指定的元素数据加入到给定`key`的**HyperLogLog**对象之中。如果`key`不存在于数据库键空间之中，则会向数据库中插入一个**HyperLogLog**对象。

### PFCOUNT命令

    PFCOUNT key [key ...]

**PFCOUNT**这个命令用于获取一个**HyperLogLog**对象截止当前的基数统计结果；如果参数给出了多个`key`，*Redis*则会将这些`key`指向的**HyperLogLog**对应的数据集合并成一个临时的数据集，并返回这个临时数据集的基数统计结果，这个临时数据集不会真正地存储在数据库键空间之中。

### PFMERGE命令

    PFMERGE destkey sourcekey [sourcekey ...]

**PFMERGE**这个命令，可以用于数据集的合并，会将多个`sourcekey`对应的数据集进行合并，并将合并结果存储于`destkey`这个键中。

## Redis中基数统计的实现细节

*Redis*没有为**HyperLogLog**对象单独实现一个数据结构，而是使用一段连续分配的内存来存储**HyperLogLog**的相关数据。同时将这段连续的内存用字符串对象类型进行包装存储在数据库的键空间之中。*Redis*实现基数统计的逻辑为：
1. 对于每一个**HyperLogLog**，*Redis*为其分配16384个寄存器，每个寄存器具有6比特大小。
1. 对于待统计数据集中的每个数据元素，通过哈希函数计算出64位的数据元素哈希值。
1. 根据64位哈希值的低14位，将这个对应元素分配到对应的**HyperLogLog**寄存器之中。
1. 剩余50位的哈希值`h`，我们定义`f(h)`返回从最低位向最高位遍历，第一次出现1的位置。例如`h=10100100000`，那么`f(h)`的值为6。
1. 每个**HyperLogLog**寄存器中，存储配分配到这个寄存器的元素哈希值对应的`f(h)`的最大值。
1. 通过收集16384个寄存器中存储的数据，通过某种计算方法，就可以获得了数据集的基数统计结果。

***
![公众号二维码](https://machiavelli-1301806039.cos.ap-beijing.myqcloud.com/qrcode_for_gh_836beef2355a_344.jpg)

喜欢的同学可以扫描二维码，关注我的微信公众号，*马基雅维利incoding*