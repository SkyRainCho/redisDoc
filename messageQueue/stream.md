# Redis可持久化的消息队列

## 消息队列的概述

简单来说消息队列可以被看做是一个存放小的容器，作为消息的生产者可以将消息存放到消息队列之中；而作为消息的消费者，当需要消息时可以从消息队列之中取出消息供自己使用。

### 为什么要使用消息队列

消息队列是分布式系统之中的一个重要的组件。应用消息队列，我们可以解决在分布式系统之中的三个比较重要的问题：

1. **异步**，分布式系统之中的处理模块只需要处理完自己负责的逻辑之后，就可以将请求扔进消息队列，由后续模块处理后续的逻辑，自己则可以继续处理其他的请求；而不用像同步模式之中那样，必须要一个请求彻底处理结束才能处理新的请求。
2. **削峰**，当分布式系统之中突然涌入大量的请求时，消息队列可以水库一样将这些请求缓存起来，这样后端的逻辑处理模块可以按照合理的速度对这些请求逐步进行处理。而不是让这些突发的请求直接冲击后端的逻辑处理模块，导致系统瘫痪。
3. **解耦**，将生成者逻辑模块与消费者逻辑模块分离，生产者只负责将数据传入消息队列，而不用关心这些数据将会被如何处理；消费者只负责将消息从消息队列之中取出并处理，而不用关系这些消息是如何产生的。

有利便必有一弊，引用消息队列也会为整个分布式系统带来一些问题：

1. 首先便是增大了系统的复杂性。这是由于引入消息队列需要将原来基于同步方式的业务逻辑改为异步的方式来实现，稍微做过一些后端系统开发的读者都会深有体会，异步模型代码的复杂度要远大于同步模型的代码复杂度。
2. 其次便是降低了系统的可用性。这一点比较容易理解，在分布式系统之中又引入了一个新的组件，势必会降低系统的可用性，一旦消息队列组件出现宕机，那么整个系统将无法对外提供服务。

因此，我们可以说消息队列并不是分布式系统之中一个必要的组件，只有在合适的场景下使用，才会提升系统的性能，盲目地随意乱用的话，有可能适得其反。

### Redis中的可以作为消息队列使用的模块

*Redis*之中的很多模块被使用者拿来当作简易的消息队列来使用，这其中包括：

#### 发布/订阅模式。

在这个模式中，生产者作为发布方向指定的频道里发布消息，消费者作为订阅方从频道中接收消息。

但是在这种模式之中存在着一些问题与隐患：

1. 通过前面我们对于发布/订阅模式内容的介绍文章，我们知道这种模式中，生产者所发布的消息会立即广播给频道上的订阅者，消息不会保存在*Redis*服务器上，这就意味着一旦频道上的某个订阅者网络出现问题，那么它将丢失这条消息。
2. 生产者发布的消息是以广播的形式发送给频道上的所有订阅者，机制上不支持消费者以互斥的方式从消息队列中获取消息这一需求。

#### 列表对象数据类型。

在这种模式中，生产者通过**LPUSH**命令向以一个列表对象的左侧插入一条消息；消费者则通过**BRPOP**命令，以阻塞的方式从该列表对象的右侧获取一条消息。

虽然使用列表对象类型，可以避免发布/订阅模式之中存在的隐患。即列表对象本身便会存储在*Redis*的键空间之中，在一定程度上避免了消息丢失的情况，同时由于阻塞操作的机制，也可以支持多个消费者以互斥的方式从消息队列中获取消息这一需要。

但是这种消息队列的实现方式也存在一些问题。一旦通过**BRPOP**命令从列表之中获取出一条消息，那么这条消息将会被从列表队列之中彻底移除，这也就意味着消费者只能获取列表中当前的消息，而无法获取历史消息。同时由于缺乏确认机制，一旦消息在从列表之中移除后没有被消费者接收，或者消费者接收到但是没有成功处理，这将造成消息的丢失。

### Redis中Stream可持久化的消息队列

为了解决前面简易*Redis*消息队列存在的隐患，在*5.0*版本之中作者引入了**Stream**对象类型，作为经典的消息队列的实现方式。通过**Stream**这个对象类型，*Redis*可以实现对消息队列的持久化；可以实现消费者都可以访问任意时刻的消息，同时还可以记录消费者的获取消息的偏移；并为提供了对消息的**ACK**确认机制，可以保证即使消费者掉线也不会出现消息丢失的情况。

同时*Redis*会为消息队列之中的每一条消息维护一个唯一的、自增的消息ID。通过消息ID，我们可以快速索引一条指定的消息，或者从消息队列之中删除指定ID的消息。

最后在*Redis*服务器的角度来看，**Stream**对象上的操作与操作其他类似字符串、列表对象无异。因此对于用作消息队列的*Redis*，同样可以应用主从复制等多机机制，以提高消息队列组件的可用性与并发性能。

在*Redis*之中，每一个**Stream**都可以关联一个*Key*存储在内存数据的键空间之中，每一个**Stream**便是一个消息队列，消息队列可以被认为是一种先进先出的数据结构，属于这个消息队列的消息都会存储这个**Stream**对象之中，同时每个消息由一个唯一的消息ID以及消息内容构成。通过**XADD**命令，我们可以向一个消息队列之中压入一条消息，**XADD**命令的格式为：

```
XADD key ID field string [field string ...]
```

这条命令向`key`所对应的**Stream**对象之中加入一条消息；`ID`字段用于指定消息的ID，如果传入`*`则表示会由*Redis*自动生成一个消息ID，这个系统自动生成的消息ID由两部分组成并且都是64位整数，第一部分是一个毫秒级的时间戳，第二部分则是一个自增的序列号，每一毫秒会清零一次；而消息的内容则是由`field`以及`string`参数构成，这相当于是一个键值对，一条消息至少要由一组键值对，由可以拥有多个键值对。命令执行成功后，会将消息的ID返回给命令的调用者。

在通过**XADD**命令完成向消息队列中插入消息之后，*Redis*还给出了**XREAD**命令，用于从消息队列之中读取消息，命令的格式为：

```
XREAD [COUNT count] [BLOCK milliseconds] STREAMS key [key ...] ID [ID ...]
```



## Redis中Stream的基础数据结构



## Redis中Stream的实现逻辑



***
![公众号二维码](https://machiavelli-1301806039.cos.ap-beijing.myqcloud.com/qrcode_for_gh_836beef2355a_344.jpg)

喜欢的同学可以扫描二维码，关注我的微信公众号，*马基雅维利incoding*