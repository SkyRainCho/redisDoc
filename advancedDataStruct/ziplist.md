# Redis中压缩链表的实现
前面我们已经介绍了*Redis*中所实现的经典双端链表了，而这种链表存在一个问题，便是在存储小数据的时候，
内存使用效率过低，例如当一个链表节点中只保存一个字节的`unsigned char`数据时，我们需要为这个节点保存24个字节的额外数据，
其中包含`listNode.prev`指针，`listNode.next`指针，以及指向具体数据的`listNode.value`指针。
为了解决经典双端链表在保存小数据而导致内存效率过低的问题，*Redis*设了一套压缩链表的数据数据结构*ziplist*来对这种场景下的链表应用进行优化。

## 压缩链表概述
压缩链表是一种专门为了提升内存使用效率而设计的，经过特殊编码的双端链表数据结构。
既可以用来保存整形数值，也可以用来保存字符串数值，为了节约内存，同时也是体现压缩之含义，
当保存一个整形数值时，压缩链表会使用一个真正的整形数来保存，而不是使用字符串的形式来存储。
这一点很容易理解，一个整数可以根据其数值的大小使用1个字节，2个字节，4个字节或者8个字节来表示，
如果使用字符串的形式来存储的话，其所需的字节数大小一定不小于使用整形数所需的字节数。

压缩链表允许在链表两端以*O(1)*的时间复杂度执行*Pop*或者*Push*操作，当然这只是一种理想状态下的情况，
由于压缩链表实际上是内存中一段连续分配的内存，因此这些操作需要对压缩链表所使用的内存进行重新分配，
所以其真实的时间复杂度是和链表所使用的内存大小相关的。

### 压缩链表的内存分布

### 链表结点的内存分布

## 压缩链表的基础操作

## 压缩链表的用户接口

***
![公众号二维码](https://machiavelli-1301806039.cos.ap-beijing.myqcloud.com/qrcode_for_gh_836beef2355a_344.jpg)

喜欢的同学可以扫描二维码，关注我的微信公众号，*马基雅维利incoding*