# Redis中紧凑列表的实现
对于这个数据结构，在*Redis*中被定义在*src/listpack.h*以及*src/listpack.c*两个文件之中，这个数据结构被*Redis*作者命名为**listpack**，参考网络上的中文资料，这个数据结构被翻译成**紧凑列表**，本文同样采用**紧凑列表**这个翻译方式。

## 紧凑列表概述
紧凑列表可以被认为是对压缩链表的一种优化。对于压缩链表，曾经有*Redis*的用户反馈在访问压缩链表的时候程序出现了崩溃，*Redis*的作者以及其他几个维护者在审核代码的过程中虽然没有查明用户所上报的崩溃的具体原因，但是意外的发现了另外一个由于压缩链表连锁更新所导致的bug，作者在`c495d095ae495ea5253443ee4562aaa30681a854`这次提交中针对这个bug进行了修改。虽然没有找到引起崩溃的bug，但是*Redis*的作者以及其他维护者一致认为压缩链表的结构所导致的连锁更新这一问题会增加压缩链表在实际应用之中的复杂性，因此他们认为需要设计一种替换压缩链表的紧凑型数据结构，而这便是紧凑列表产生的原因。

紧凑列表吸纳了压缩链表的优势同时又进行了重新实现，可以以更紧凑的方式来表示数据，同时还能够更加快速的对数据进行解析。重要的是，紧凑列表中单一节点的表示形式被重新设计以便更好地拓展这种数据形式，

	<tot-bytes> <num-elements> <element-1> ... <element-N> <listpack-end-byte>

紧凑列表会被存储在一段连续的线性内存块中，紧凑列表具有一个6字节固定长度的头部数据，这相较于压缩链表10个字节的头部数据，紧凑列表缺少了指向最后一个元素的偏移字段。头部数据之后便是紧凑列表的数据元素节点，另外从理论上来说紧凑列表并不需要一个标记结束的终止符，但是处于某些考虑，*Redis*仍然提供了一个值为`0XFF`的特殊的终止符。使用终止符的优点在于对列表进行扫描的时候，不需要一直记录列表结尾的地址，并在每次迭代的时候都进行比较，这个优点也是作者认为需要在紧凑列表中保留终止符的主要原因。

1. 其中`<tot-bytes>`字段是共4个字节，用于表示紧凑列表所占用的字节的总数，这个大小包含了紧凑列表的头部数据以及结尾的终止符，通过这个字段中存储的偏移量，可以快速定位到紧凑列表的结尾，以实现对列表的反向遍历。
2. `<num-elements>`字段共2个字节，用于存储当前紧凑列表中元素节点的个数，与压缩链表相似，这个表示表中元素个数的字段存在他的上限，如果超过上限，那么需要遍历整个表才能够获取它的真实长度。

紧凑列表中每一个元素节点都拥有如下的数据结构

	<encoding-type><element-data><element-tot-len>
	|                                            |
	+--------------------------------------------+
	            (This is an element)

对于每一个紧凑列表元素节点来说，节点类型`<encoding-type>`以及节点总长度`<element-tot-len>`始终都是存在的。节点数据本身`<element-data>`有时候会不存在，因为对于某些较小的数据，其本身会被存储在`<encoding-type>`的备用字段中。

在这其中，`<encoding-type>`这个字段用于表示当前元素节点的类型，这个字段一个长度可变的字段，从1个字节到9个字节，其中保存着存储数据的类型，如果存储的是一个整形数字，那么该整数值也会被存储在这个字段之中；如果存储的是一个字符串数据，那么字符串数据的长度将会被存储在这个字段之中：
|编码类型|二进制表示|字节数|描述|
|--------|----------|------|----|
|`#define LP_ENCODING_7BIT_UINT 0`|`[0XXXXXXX]`|1字节|用后7位来存储这个整数值|
|`#define LP_ENCODING_6BIT_STR 0x80`|`[10XXXXXX]`|1字节|用后6位来存储后续字符串的长度|
|`#define LP_ENCODING_13BIT_INT 0xC0`|`[110XXXXX][one byte]`|2字节|使用第一个字节的后5位以及后续的一个字节来存储整数值|
|`#define LP_ENCODING_12BIT_STR 0xE0`|`[1110XXXX][one byte]`|2字节|使用第一个字节的后4位以及后续的一个字节来存储字符串的长度|
|`#define LP_ENCODING_16BIT_INT 0xF1`|`[11110001][two bytes]`|3字节|使用后两个字节来存储16位整数|
|`#define LP_ENCODING_24BIT_INT 0xF2`|`[11110010][three bytes]`|4字节|使用后三个字节来存储24位整数|
|`#define LP_ENCODING_32BIT_INT 0xF3`|`[11110011][four bytes]`|5字节|使用后四个字节来存储32位整数|
|`#define LP_ENCODING_64BIT_INT 0xF4`|`[11110100][eight bytes]`|9字节|使用后八个字节来存储64位整数|
|`#define LP_ENCODING_32BIT_STR 0xF0`|`[11110000][four bytes]`|5字节|使用后四个字节来存储字符串长度|

通过这个`<encoding-type>`字段，紧凑列表可以实现节点的正向遍历。

而`<element-tot-len>`则是用来存储其所在节点`<encoding-type>`以及`<element-data>`这两个字段的长度，通过这个字段，*Redis*可以实现对紧凑列表的方向遍历，`<element-tot-len>`字段也是一个变长字段，其长度范围可以从1个字节到5个字节，对于这个字段，*Redis*采用一种特殊的设计方式，首先长度数据编码的高位存储在这个字段的低位字节上，而编码的地位则存储在该字段的高位字节上，这样是为了方便反向遍历时，从高到低地遍历字节，以获取长度编码数据；另外一个特殊的设计之处为，每个字节只使用低位的7个比特来存储数据，而高位的1比特则用来标记是否达到了字段的其实位置：
|长度范围|二进制表示|字段长度|
|--------|----------|--------|
|`[1, 127]`|`[0XXXXXXX]`|1字节|
|`(127, 16383)`|`[0XXXXXXX][1XXXXXXXX]`|2字节|
|`[16383, 2097151)`|`[0XXXXXXX][1XXXXXXX][1XXXXXXX]`|3个字节|

4字节与5字节`<element-tot-len>`与上面这个表格中的形式类似，那么通过这样的设计便可以实现对给定元素节点的反向遍历，给定紧凑列表指针`lp`以及元素节点指针`p`，那么这个反向遍历的过程应该为：
1. 如果`lp`指针与`p`正好相差6个字节（也就是紧凑列表头部数据的长度），那么说明`p`对应的节点为列表的第一个节点，无法反向遍历。
2. 如果不是情况1，那么将`p`指针减去1个字节，使之指向前一个节点`<element-tot-len>`的最后一个字节。
3. 用`p`指针向前依次扫描每一个字节，直到找到高位比特为0的字节，并将中间扫描的数据进行累加，计算出前一个节点`<encoding-type>`以及`<element-data>`这两个字段的长度。

对于紧凑列表来说，每一个节点元素只包含和该节点有关的数据；而压缩链表中，每一个节点元素还包含了其前一个节点的长度数据，正是这种设计方式导致在对压缩链表节点数据进行操作时，有可能引发连锁更新的问题。而应用紧凑链表的这种设计方式，无论是对插入新节点，还是删除老的节点，亦或是对已有节点的修改，都不会产生连锁更新的问题。

很遗憾，虽然*Redis*为了寻求替代压缩链表而设计了这个紧凑列表的数据结构，但迄今为止，紧凑列表只在*Redis*中的*Stream*对象类型之中被使用，而列表对象，散列对象与有序集合对象中，仍旧使用的是压缩链表，期待在未来的某个版本里，紧凑列表能够完全替代压缩链表。

## 紧凑列表接口API
虽然紧凑列表在分布结构上与压缩链表存在差异，但是本质上二者的实现原理是一致的，而且紧凑列表本身便是对压缩链表的一种优化。因此，紧凑列表的接口API在实现方式上也是与压缩链表相类似的，所以在这一部分，将不对紧凑列表接口的具体实现进行讲解，仅会介绍每个接口的功能。

### 紧凑列表的创建与释放
```c
unsigned char *lpNew(void);
```
`lpNew`函数用于创建一个空的紧凑列表，如果创建成功，那么会返回这个新的列表的指针；否则如果无法创建紧凑列表，则函数会返回空指针。

```c
void lpFree(unsigned char *lp);
```
`lpFree`函数用于释放给定的紧凑列表。

### 紧凑列表的插入与删除
```c
unsigned char *lpInsert(unsigned char *lp, unsigned char *ele, uint32_t size, unsigned char *p, int where, unsigned char **newp);
```
这个函数用于向紧凑列表`lp`之中插入一个长度为`size`的数据`ele`，插入的位置由指向某一个列表中节点的指针`p`，以及插入位置`where`指定的，`where`的值可以为下面三项：
1. `#define LP_BEFORE 0`，用于插入到`p`节点之前，也就是左侧。
2. `#define LP_AFTER 1`，插入到`p`节点之前，也就是右侧。
3. `#define LP_REPLACE 2`，用于替换`p`节点。

另外如果`ele`指针传入空值，则表示删除`p`节点。

```c
unsigned char *lpAppend(unsigned char *lp, unsigned char *ele, uint32_t size);
```
`lpAppend`函数会将`ele`以及`size`所指定的元素追加到`lp`这个紧凑列表的结尾，函数返回执行追加操作之后紧凑列表的指针。

```c
unsigned char *lpDelete(unsigned char *lp, unsigned char *p, unsigned char **newp);
```
`lpDelete`这个函数用于从紧凑列表`lp`中删除`p`指针所指向的元素节点，函数返回删除节点之后的紧凑列表的指针，如果参数`newp`非空，那么被删除的节点的右侧的节点会从这个`newp`参数返回给调用者。

### 紧凑列表的长度获取
```c
uint32_t lpLength(unsigned char *lp);
```
`lpLength`函数会返回指定紧凑列表`lp`中元素节点的个数。除非有必要对整个列表进行扫描，否则这个函数首先会尝试使用存储在紧凑列表头部数据中缓存的节点个数。作为调用这个函数的一个附带的影响，紧凑列表的头部信息有可能会被修改，如果在对整个列表遍历后所得的节点个数可以在`<num-elements>`的表示范围内，那么会将新的个数更新到`<num-elements>`字段里。

```c
uint32_t lpBytes(unsigned char *lp);
```
`lpBytes`函数会返回指定紧凑列表`lp`所占用的字节数。

### 紧凑列表的遍历
```c
unsigned char *lpFirst(unsigned char *lp);
```
`lpFirst`函数会返回紧凑列表`lp`中的第一个节点的指针，如果紧凑列表为空，那么调用该函数会返回一个空指针。

```c
unsigned char *lpLast(unsigned char *lp);
```
`lpLast`函数会返回紧凑列表`lp`中的最后一个节点的指针，如果紧凑列表为空，那么调用该函数会返回一个空指针。

```c
unsigned char *lpNext(unsigned char *lp, unsigned char *p);
```
如果指针`p`指向紧凑列表`lp`中的一个元素节点，那么调用`lpNext`函数将会返回`p`元素的后一个节点，也就是它右侧的节点，如果`p`已经是指向紧凑列表中的最后一个节点，那么调用该函数会返回空指针`NULL`。

```c
unsigned char *lpPrev(unsigned char *lp, unsigned char *p);
```
如果指针`p`指向紧凑列表`lp`中的一个元素节点，那么调用`lpPrev`函数将会返回`p`元素的前一个节点，也就是它左侧的节点，如果`p`已经是指向紧凑列表中的第一个节点，那么调用该函数会返回一个空指针。

### 紧凑列表的获取与查找
```c
unsigned char *lpGet(unsigned char *p, int64_t *count, unsigned char *intbuf);
```
`lpGet`这个函数用于返回`p`指针所指向的紧凑列表节点元素。这个函数的行为与传入的参数`intbuf`有关：
1. 如果是字符串编码，函数会返回指向字符串数据的指针，同时将字符串长度存储在`count`之中。
2. 如果是整数编码，函数会返回空指针`NULL`，如果`intbuf`参数传入为`NULL`，那么解码出的整数会通过`count`进行返回；如果`intbuf`不传空值，那么解码出的整数会按照字符串的形式存储在`intbuf`所指向的缓存之中，调用者需要确保`intbuf`所指向的缓存要有`LP_INTBUF_SIZE`这么多的空间。

```c
unsigned char *lpSeek(unsigned char *lp, long index);
```
`lpSeek`函数用于从指定的紧凑列表`lp`中搜索指定所有`index`的节点，同时返回这个节点指针。正数索引从0开始，用于正向的搜索节点；负数的索引则是从-1开始，用于反向的搜索节点。如果索引超过了紧凑列表的范围，那么函数将返回一个空指针。

***
![公众号二维码](https://machiavelli-1301806039.cos.ap-beijing.myqcloud.com/qrcode_for_gh_836beef2355a_344.jpg)

喜欢的同学可以扫描二维码，关注我的微信公众号，*马基雅维利incoding*
