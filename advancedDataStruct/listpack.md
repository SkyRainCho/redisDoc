# Redis中紧凑列表的实现
对于这个数据结构，在*Redis*中被定义在*src/listpack.h*以及*src/listpack.c*两个文件之中，可以认为这个数据结构被*Redis*作者命名为**listpack**，参考网络上的中文资料，这个数据结构被翻译成**紧凑列表**，本文同样采用**紧凑列表**这个翻译方式。

## 紧凑列表概述
紧凑列表可以被认为是对压缩链表的一种优化。对于压缩链表，曾经有*Redis*的用户反馈在访问压缩链表的时候程序出现了崩溃，*Redis*的作者以及其他几个维护者在审核代码的过程中虽然没有查明用户所上报的崩溃的具体原因，但是意外的发现了另外一个由于压缩链表连锁更新所导致的bug，作者在`c495d095ae495ea5253443ee4562aaa30681a854`这次提交中针对这个bug进行了修改。虽然没有找到引起崩溃的bug，但是*Redis*的作者以及其他维护者一致认为压缩链表的结构所导致的连锁更新这一问题会增加压缩链表在实际应用之中的复杂性，因此他们认为需要设计一种替换压缩链表的紧凑型数据结构，而这便是紧凑列表产生的原因。

紧凑列表吸纳了压缩链表的优势同时又进行了重新实现，可以以更紧凑的方式来表示数据，同时还能够更加快速的对数据进行解析。重要的是，紧凑列表中单一节点的表示形式被重新设计以便更好地拓展这种数据形式，

	<tot-bytes> <num-elements> <element-1> ... <element-N> <listpack-end-byte>

紧凑列表会被存储在一段连续的线性内存块中，紧凑列表具有一个6字节固定长度的头部数据，这相较于压缩链表10个字节的头部数据，紧凑列表缺少了指向最后一个元素的偏移字段。头部数据之后便是紧凑列表的数据元素节点，另外从理论上来说紧凑列表并不需要一个标记结束的终止符，但是处于某些考虑，*Redis*仍然提供了一个值为`0XFF`的特殊的终止符。使用终止符的优点在于对列表进行扫描的时候，不需要一直记录列表结尾的地址，并在每次迭代的时候都进行比较，这个优点也是作者认为需要在紧凑列表中保留终止符的主要原因。

1. 其中`<tot-bytes>`字段是共4个字节，用于表示紧凑列表所占用的字节的总数，这个大小包含了紧凑列表的头部数据以及结尾的终止符，通过这个字段中存储的偏移量，可以快速定位到紧凑列表的结尾，以实现对列表的反向遍历。
2. `<num-elements>`字段共2个字节，用于存储当前紧凑列表中元素节点的个数，与压缩链表相似，这个表示表中元素个数的字段存在他的上限，如果超过上限，那么需要遍历整个表才能够获取它的真实长度。

紧凑列表中每一个元素节点都拥有如下的数据结构

	<encoding-type><element-data><element-tot-len>
	|                                            |
	+--------------------------------------------+
	            (This is an element)

对于每一个紧凑列表元素节点来说，节点类型`<encoding-type>`以及节点总长度`<element-tot-len>`始终都是存在的。节点数据本身`<element-data>`有时候会不存在，因为对于某些较小的数据，其本身会被存储在`<encoding-type>`的备用字段中。

在这其中，`<encoding-type>`这个字段用于表示当前元素节点的类型，这个字段一个长度可变的字段，从1个字节到9个字节，其中保存着存储数据的类型，如果存储的是一个整形数字，那么该整数值也会被存储在这个字段之中；如果存储的是一个字符串数据，那么字符串数据的长度将会被存储在这个字段之中：
|编码类型|二进制表示|字节数|描述|
|--------|----------|------|----|
|`#define LP_ENCODING_7BIT_UINT 0`|`[0XXXXXXX]`|1字节|用后7位来存储这个整数值|
|`#define LP_ENCODING_6BIT_STR 0x80`|`[10XXXXXX]`|1字节|用后6位来存储后续字符串的长度|
|`#define LP_ENCODING_13BIT_INT 0xC0`|`[110XXXXX][one byte]`|2字节|使用第一个字节的后5位以及后续的一个字节来存储整数值|
|`#define LP_ENCODING_12BIT_STR 0xE0`|`[1110XXXX][one byte]`|2字节|使用第一个字节的后4位以及后续的一个字节来存储字符串的长度|
|`#define LP_ENCODING_16BIT_INT 0xF1`|`[11110001][two bytes]`|3字节|使用后两个字节来存储16位整数|
|`#define LP_ENCODING_24BIT_INT 0xF2`|`[11110010][three bytes]`|4字节|使用后三个字节来存储24位整数|
|`#define LP_ENCODING_32BIT_INT 0xF3`|`[11110011][four bytes]`|5字节|使用后四个字节来存储32位整数|
|`#define LP_ENCODING_64BIT_INT 0xF4`|`[11110100][eight bytes]`|9字节|使用后八个字节来存储64位整数|
|`#define LP_ENCODING_32BIT_STR 0xF0`|`[11110000][four bytes]`|5字节|使用后四个字节来存储字符串长度|

通过这个`<encoding-type>`字段，紧凑列表可以实现节点的正向遍历。

而`<element-tot-len>`则是用来存储其所在节点`<encoding-type>`以及`<element-data>`这两个字段的长度，通过这个字段，*Redis*可以实现对紧凑列表的方向遍历，`<element-tot-len>`字段也是一个变长字段，其长度范围可以从1个字节到5个字节，对于这个字段，*Redis*采用一种特殊的设计方式，首先长度数据编码的高位存储在这个字段的低位字节上，而编码的地位则存储在该字段的高位字节上，这样是为了方便反向遍历时，从高到低地遍历字节，以获取长度编码数据；另外一个特殊的设计之处为，每个字节只使用低位的7个比特来存储数据，而高位的1比特则用来标记是否达到了字段的其实位置：
|长度范围|二进制表示|字段长度|
|--------|----------|--------|
|`[1, 127]`|`[0XXXXXXX]`|1字节|
|`(127, 16383)`|`[0XXXXXXX][1XXXXXXXX]`|2字节|
|`[16383, 2097151)`|`[0XXXXXXXd[1XXXXXXX][1XXXXXXX]]`|3个字节|

4字节与5字节`<element-tot-len>`与上面这个表格中的形式类似，那么通过这样的设计便可以实现对给定元素节点的反向遍历，给定紧凑列表指针`lp`以及元素节点指针`p`，那么这个反向遍历的过程应该为：
1. 如果`lp`指针与`p`正好相差6个字节（也就是紧凑列表头部数据的长度），那么说明`p`对应的节点为列表的第一个节点，无法反向遍历。
2. 如果不是情况1，那么将`p`指针减去1个字节，使之指向前一个节点`<element-tot-len>`的最后一个字节。
3. 用`p`指针向前依次扫描每一个字节，直到找到高位比特为0的字节，并将中间扫描的数据进行累加，计算出前一个节点`<encoding-type>`以及`<element-data>`这两个字段的长度。

对于紧凑列表来说，每一个节点元素只包含和该节点有关的数据；而压缩链表中，每一个节点元素还包含了其前一个节点的长度数据，正是这种设计方式导致在对压缩链表节点数据进行操作时，有可能引发连锁更新的问题。而应用紧凑链表的这种设计方式，无论是对插入新节点，还是删除老的节点，亦或是对已有节点的修改，都不会产生连锁更新的问题。


***
![公众号二维码](https://machiavelli-1301806039.cos.ap-beijing.myqcloud.com/qrcode_for_gh_836beef2355a_344.jpg)

喜欢的同学可以扫描二维码，关注我的微信公众号，*马基雅维利incoding*
