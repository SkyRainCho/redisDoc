# Redis脚本

我们知道在关系型数据库之中，存在一个存储过程的一个概念。由于关系型数据自身仅仅能够提供增删改查这种基础功能，无法执行复杂逻辑，而所谓存储过程是一种在数据库中存储复杂程序，以便外部程序调用的一种数据库对象。存储过程本质上时为了完成特定功能的SQL语句集，经过编译创建并保存在数据库之中，数据库的用户可以指定存储过程的名字并给定参数来调用执行，用以实现数据库SQL语言层面的代码封装与复用。

*Redis*虽然不是关系型数据库，但是也为用户提供了类似存储过程的功能。这个功能的核心是*Redis*内部集成了一个Lua脚本的解释器，用户可以通过Lua脚本来原子地调用一条或者多条*Redis*命令，并且可以集成一定的用户自定义逻辑。

## Redis脚本概述

除了执行Lua脚本之外，*Redis*可以通过**PIPELINE**以及事务功能来一次性地执行多条命令，那么这三种方式有什么区别呢？

首先，**PIPELINE**机制完全是客户端的行为，客户端一次性将多条命令发送至*Redis*服务器，这个机制完全得益于*Redis*服务器核心所使用的事件驱动处理逻辑。这种方式虽然可以一次性地执行多条*Redis*命令，但是却无法保证命令执行的原子性。这一点在前面介绍*Redis*客户端对象那一部分的文章之中有过介绍。

事务功能，会在客户端执行**MULTI**命令时，将客户端对象设置成一个事务状态，后续用户通过客户端执行的命令都会被缓存起来，而不是立即执行；最后当用户通过客户端执行**EXEC**命令时，前面被缓存起来的命令会一次性地原子的执行。而事务功能中，命令的执行过程不会被其他客户端所打断，具备原子性。然而事务功能也有它的局限性，它只能简单地执行多条*Redis*的原生命令，却对逻辑进行自定义。例如，我们希望根据*Redis*数据之中的某个特定键中存储的数值的不同，后续执行不同的命令，这种场景事务功能则是爱莫能助，如果将这个逻辑放在客户端去执行，先通过**GET**命令获取某一个键的值，在根据值的不同向服务器发起不同的命令，而这样的话又无法保证逻辑的原子性。

而Lua脚本恰恰是为了解决上面的这个场景需求所设计的，用户可以向*Redis*服务器发送一段Lua脚本代码段，在代码段之中可以调用*Redis*命令并获得命令的返回值，同时我们还可以使用Lua脚本语法不同的逻辑执行不同的*Redis*命令。而在一段Lua代码段之中的所有Lua逻辑以及*Redis*命令的执行是原子性的，不会被其他客户端的命令所打断。

### EVAL与EVALSHA命令

上述这两个命令是*Redis*中执行Lua脚本的入口，首先我们来看一下**EVAL**命令的格式：

```
EVAL script numkeys key [key ...] arg [arg ...]
```

这个命令之中，`script`是一段Lua脚本片段，这段代码片段不应该被定义为一个函数。在这段Lua代码之中，可以通过`redis.call()`以及`redis.pcall（）`来调用*Redis*的原生命令。`numkeys`参数可以指定传入脚本之中的`key`参数的个数；后面的`key`则表示在脚本中能够用的*Redis*中的键参数，在脚本之中可以用`KEYS[1]`、`KEYS[2]`这样的形式引用这些参数。而最后的参数`arg`则是表示不是*Redis*键的参数，在脚本之中可以用`ARGV[1]`，`ARGV[2]`这样的形式来进行引用。

```
EVAL "return redis.call('set', KEYS[1], ARGV[1])" 1 script:key script:value
```

上述这条命令，相当于在*Redis*上执行一条**SET**命令，为`script:key`这个键设置`script:value`的值。

### SCRIPT命令



## Redis脚本代码实现

### Redis脚本数据结构

### Redis脚本实现逻辑

***
![公众号二维码](https://machiavelli-1301806039.cos.ap-beijing.myqcloud.com/qrcode_for_gh_836beef2355a_344.jpg)

喜欢的同学可以扫描二维码，关注我的微信公众号，*马基雅维利incoding*